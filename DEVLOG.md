# FelineGuard Engineering Log

## 2026-01-27: Motor Testing

Today, upon successful physical connections made yesterday among Smy STM32 board, the A4988 Motor Driver, and the NEMA 17 Stepper Motor, I was able to reuse both the GPIO driver and the TIM driver I previously implemented for my PWM breathing LED demo.

While the maximum frequency of my STM32F446RE board is 180MHz, since I never manually overclocked it by changing the RCC settings, it is at its default speed 16MHz. Now, the equation to calculate frequency of a specific register is given as "16MHz / (ARR + 1)(PSC + 1)". 

I used PA0 to control STEP of motor driver, and PA1 to set DIR. Initially, I tested by Enabling TIM2 through Channel 1 on PA0, and I specifically set PSC to 15 and ARR to 999, with our equation above, I calculate that the PWM frequency generated by PA0 is 16MHz / (15+1)(999+1) = 1000Hz. The motor worked perfectly fine, spinning constantly at a relatively high speed. When I set DIR to 1, the motor would turn clockwise, and when it is set to 0, the motor would turn counterclockwise, which is pretty cool. I like the feeling of being able to control hardware by connecting hardwares and writing code.

One key takeaway is that, although both the breathing LED demo and the motor uses the same TIM2 peripheral to generate PWM waves, which is basically just a square wave. Logically, they serve different purposes. To elaborate, let me use the same settings as an example for both cases. In the LED demo, the purpose of using TIM2 to generate PWM wave is to set the "brightness" by using the capcture/compare registers. According to the manual, channel 1 is active as long as TIMx_CNT < TIMx_CCR1. when CR1 register of TIM2 is enabled, the hardware constantly counts from 0 to whatever ARR I set to as its "endpoint", for example, in our case, 999. it means that CNT constantly goes from 0 to 999, and then reset to 0, and then repeat this over and over. Now, with that being said, ARR sets the "length", but PSC sets the "pace", or to put it in another way, PSC decides how fast CNT counts from 0 to 999.

I learned that, the overall frequency eventually sets the speed at which the motor turns. Let's keep the motor speed as an invariant, so to achieve the same ferequence generated by PSC = 15 and ARR = 999, and we could get the same by setting PSC to 3 and ARR to 5000. We "benefit" from having a bigger ARR. Let's go back to the PWM breathing LED example, I used a software delay to achive "breathing". However, PWM wave handleded the "brightness" part. During each software iteration, by setting CCR1 to i, since it takes much less time for the hardware timer to count form 0 to 999 than software loop to go from i = 0 to i = 1, thus, each ARR value represents a level of brightness. Logically, since we use 0% to 100% to represent the brightness, setting ARR to 999 means that at each CCR1 value, the brightness difference is 0.01%. In other words, ARR decides the "resolution", and the bigger the ARR, the more precise and "smoother" it will be.

One more thing I learned is that, even though the brightness was controlled by value of CCR1 in the LED demo, duty cycle does not matter at all to our motor. For example, when ARR is 999, and if we set CCR1 to 500, during each cycle, half the time PA0 would output high voltage 1, while the other half time low voltage 0. Motor drivers only read that "rising edge", that instant voltage goes from low to high, 0 to 1, and it turns based on how many cycles, "pulses" it receives per second just for our reference. It does not care whether it receives the fall edge during the first half of the cycle or the second half.

Lastly, when I kept PSC at 15 and changed ARR to 800, even though CCR1 was 500, being in the valid range, the motor would "horn" but not spin. I learned from AI that this has to do with the maximum frequency the motor could handle, because if the freuency was too high, the coils inside the motor would not turn for physics reasons, which I am not that familiar with. Again, this only proves that, is it exteremly important to consider the proper PSC and ARR to set when we want to generate a PWM wave for different purposes. But in general, higher ARR benefits a lot.

## 2026-01-26: Hardware Integration & Driver Logic Setup

Today, I spent several hours figuring out how to properly set up the physical connections between my STM32F4 board, the A4988 Motor Driver, and the NEMA 17 Stepper Motor before diving into the Bare-Metal driver implementation.

Here is the logic behind the setup and my key takeaways:

### 1. The Role of the Motor Driver
Essentially, the motor driver acts as a "transfer station" between the STM32 microcontroller and the motor. The STM32 operates at **3.3V** with a current limit of roughly **125mA** (total), while the NEMA 17 requires **0.8A to over 2A** depending on the load.
Direct connection is impossible: a source suitable for the STM32 cannot drive the motor, and a source powerful enough for the motor would instantly fry the microcontroller. The A4988 driver bridges this gap.

### 2. Physical Wiring & Lessons Learned
Following Rachel De Barros's guide, I successfully set up the connections:
* **SLP (Sleep) and RST (Reset):** I connected these two pins in parallel using a short jumper wire. If left unconnected (floating), they might default to a low state, causing the driver to sleep or reset. Connecting them together effectively pulls them high to keep the driver active.
* **VMOT & GND:** I used a 12V source for the "muscle voltage" to actually drive the motor.
* **VDD & GND:** I connected these to the 5V and GND pins on the STM32 board. VDD stands for **Logic Supply Voltage**. It powers the internal logic circuits of the A4988—the "brain" that interprets signals—while VMOT powers the "muscle."

### 3. Concept Correction: Signal vs. Power
I corrected a previous assumption: even though the STM32 controls the driver via low-current signals, the driver itself holds back the 12V power like a dam holding water. The STM32 signal is merely the valve handle; it tells the driver when to release the 12V current to the motor coils. The signal itself does not drive the motor.

### 4. Theory vs. Reality (The Capacitor)
Building this circuit highlighted the difference between ideal lecture theory and engineering reality. In ideal circuit theory, connecting a capacitor in parallel with a DC voltage source is tricky because voltage across a capacitor cannot change instantaneously, theoretically causing infinite current surges.
However, in the real world, a **100µF decoupling capacitor** is essential here. It acts as a local energy reservoir to smooth out voltage spikes (inductive kickback) caused by the motor coils and protects the driver from damage.

### 5. Pin Selection & Documentation Navigation
To control the motor, I need two pins (`STEP` and `DIR`). I specifically wanted to use **TIM2** (a General Purpose Timer), as I am already familiar with it from my PWM LED demo.
I had to navigate four different documents, finally understanding the specific purpose of each:
1.  **Datasheet (STM32F446xC/E):** The "Menu." It tells me what alternate functions (AF) each pin physically supports (e.g., "PA0 supports TIM2_CH1 via AF1").
2.  **Reference Manual (RM0390):** The "Bible." It details memory addresses, register offsets, and bit definitions. I use this the most.
3.  **User Manual (UM1724):** The "Board Manual." It explains Nucleo-specific features (e.g., PA5 is connected to the onboard LED, PC13 to the User Button).
4.  **Programming Manual (PM0214):** The "Assembly Guide." Details the Cortex-M4 instruction set.

### 6. AI Assistance vs. Engineering Judgment
I must credit Gemini for helping me ramp up on STM32 fundamentals. However, when it suggested using **PA8 and PA9** for the motor, I verified this against the Datasheet.
* **The Conflict:** `PA8`/`PA9` connect to **TIM1**, an Advanced Timer. While powerful, TIM1 requires extra configuration (like Deadtime insertion and Break inputs) which complicates the code.
* **The Decision:** I prefer the **KISS principle (Keep It Simple, Stupid)**. I only need basic PWM (PSC/ARR configuration).
* **The Solution:** By cross-referencing the Alternate Function table, I selected **PA0 and PA1**. They support **TIM2**, are free from UART conflicts (`PA2`/`PA3`), and leave I2C/SPI pins open for future sensor expansion.

### Conclusion
AI is a powerful efficiency tool, but it often lacks context or prioritizes complexity over simplicity. As a Computer Engineering student aiming for a firmware career, system verification is my responsibility. I learned that verifying datasheet information is just as critical as verifying physical wiring.

<img width="1133" height="800" alt="9a54fb2dc44838447d41101ac381234b" src="https://github.com/user-attachments/assets/c540057b-c729-4c7f-af9d-a29cc8de63f1" />

<img width="822" height="618" alt="image" src="https://github.com/user-attachments/assets/cb0b26e9-6c26-4662-bee9-dcb3101a7f9c" />



## 2026-01-26: The "Pivot" to Bare-Metal Drivers
* **Status Change:** Paused mechanical fabrication to focus entirely on Firmware reliability.
* **Reasoning:** ECE 35 Professor Curt advised that the original "Collar" idea had strict weight constraints (<1% of body weight). While I shifted to a Feeder design, I realized that **the mechanical shell is secondary to the control logic**.
* **Decision:**
    * **Shelved:** 3D printing tasks (will resume after firmware verification).
    * **Active:** Building a "Hardware-in-the-loop" MVP using just the STM32, A4988, and Nema 17 on a breadboard.
    * **Goal:** Prove I can control the motor precisely with register-level C code before I worry about the plastic shell.

---
*(Previous Entries Below)*

## 2026-01-09: Mechanical Research (Archived)
* **Design Research:** Evaluated open-source designs (Thingiverse "NorthernLayers") to avoid reinventing the wheel.
* **Plan:** Selected Nema 17 for high torque requirements.
* **Note:** This phase is currently on hold while I develop the STM32 drivers.
