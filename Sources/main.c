/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h> // for strlen()
#include "stm32f446xx.h"
#include "stm32f446xx_gpio_driver.h"
#include "stm32f446xx_timer_driver.h"
#include "stm32f446xx_uart_driver.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* --- Global Variables --- */
USART_Handle_t USART2_Handle; // declared here to reuse in USART_SendData in main() function

void software_delay(uint32_t count){
    for(uint32_t i = 0; i < count; i++){
    	__asm("NOP");
    }
}

void Setup_Peripherals(void){ // void as parameter emphasizes that this function will not take in anything
	/*
	 * ========================================
	 * 			RCC Configuration
	 * ========================================
	 */
	GPIOA_PCLK_EN(); // nothing works unless Port A is first Enabled
	TIM2_PCLK_EN(); // similarly, TIM2 will not work unless it is enabled
	USART2_PCLK_EN();

	/*
	 * ========================================
	 * 		PA0 (STEP) Configuration
	 * ========================================
	 */
	GPIO_Handle_t GPIO_STEP; // PA0

	GPIO_STEP.pGPIOx = GPIOA; // set the correct Port Group

	GPIO_STEP.GPIO_PinConfig.GPIO_PinNumber = 0; // Pin 0
	GPIO_STEP.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTN; // set to Alternate Function mode
	GPIO_STEP.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_VERY_HIGH; // high speed since we are generating PWM wave
	GPIO_STEP.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD; // no need for pull-up resistor to be enabled, this is controlled by software, not hardware button
	// no need to set output type because the MODER is not set to Output mode
	GPIO_STEP.GPIO_PinConfig.GPIO_PinAltFunMode = GPIO_AF_1; // TIM2_CHI/TIM2_ETR enabled at AF1 for PA0

	GPIO_Init(&GPIO_STEP); // use GPIO_Init implemented in gpio_driver.c to Configure PA0 registers

	/*
	 * ========================================
	 * 		PA1 (DIR) Configuration
	 * ========================================
	 */
	GPIO_Handle_t GPIO_DIR; // PA1

	GPIO_DIR.pGPIOx = GPIOA;

	GPIO_DIR.GPIO_PinConfig.GPIO_PinNumber = 1;
	GPIO_DIR.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT; // output mode to send signal
	GPIO_DIR.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_MEDIUM; // no need to use high speed, this will save some power
	GPIO_DIR.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP; // default mode (Open Drain will be used for I2C)
	GPIO_DIR.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD; // again, this will be set by purely software, there is no external hardware button, so need for pull-up/down resistors to be enabled

	GPIO_Init(&GPIO_DIR); // forgot to initialize, causing compilation error
	/*
	 * ========================================
	 * 		TIM2 (PWM) Configuration
	 * ========================================
	 */
	TIM_Handle_t TIMER2;
	TIMER2.pTIMx = TIM2;
	TIMER2.TIM_Config.Prescaler = 15; // PSC
	TIMER2.TIM_Config.Period = 3000; // ARR

	TIM_PWM_Init(&TIMER2); // Configure TIM2

	/* ---------- USART2 Configuration ----------*/

	/*
	 * ========================================
	 * 		PA2 (TX) Configuration
	 * ========================================
	 * according to Table 11. Alternate function at page 57 in datasheet
	 * when PA2 is set to AF7
	 * it can use USART2_TX
	 */
	GPIO_Handle_t USART2_TX;

	USART2_TX.pGPIOx = GPIOA;
	USART2_TX.GPIO_PinConfig.GPIO_PinNumber = 2;
	USART2_TX.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTN;
	USART2_TX.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_VERY_HIGH;
	USART2_TX.GPIO_PinConfig.GPIO_PinAltFunMode = GPIO_AF_7 ;
	USART2_TX.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU; // pull-up
	USART2_TX.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP; // default

	GPIO_Init(&USART2_TX);

	/*
	 * ========================================
	 * 		PA3 (RX) Configuration
	 * ========================================
	 * when PA3 is set to AF7
	 * it can use USART2_RX
	 *
	 * --------------- NOTE ---------------
	 * Both TX/RX are configured with internal pull-ups to ensure the line remains
	 * in a stable IDLE (High) state. This avoids floating-point noise that might
	 * be misinterpreted as a START bit (Low), preventing the receiver from
	 * sampling garbage data.
	 */
	GPIO_Handle_t USART2_RX;

	USART2_RX.pGPIOx = GPIOA;
	USART2_RX.GPIO_PinConfig.GPIO_PinNumber = 3;
	USART2_RX.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTN;
	USART2_RX.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_VERY_HIGH;
	USART2_RX.GPIO_PinConfig.GPIO_PinAltFunMode = GPIO_AF_7 ;
	USART2_RX.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU; // pull-up
	USART2_RX.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP; // default

	GPIO_Init(&USART2_RX);

	/*
	 * ========================================
	 * 		USART2 Configuration
	 * ========================================
	 * since I only use it for testing purposes (Serial Print)
	 * and giving command to turn the motor from my end
	 * I use the standard "8-N-1" setup
	 * 1. 8 bits as word length (not 9 since I will not use parity)
	 * 2. None parity (unless signal is not stable, it is not needed)
	 * 3. Stop Bits -> 1 (not too fast, not too slow, right in the middle)
	 */
	USART2_Handle.pUSARTx = USART2;
	USART2_Handle.USART_Config.USART_MODE = USART_MODE_TXRX;
	USART2_Handle.USART_Config.USART_WordLength = USART_WordLength_8;
	USART2_Handle.USART_Config.USART_ParityControl = USART_Parity_DISABLE;
	USART2_Handle.USART_Config.USART_StopBits = USART_StopBits_1;
	USART2_Handle.USART_Config.USART_Baud = USART_Baud_115200;

	USART_Init(&USART2_Handle);
}

int main(void)
{
	Setup_Peripherals(); // set up hardware

	GPIO_WriteToOutputPin(GPIOA, 1, DISABLE);

	while (1){
		// LED2 blinks to indicate system working
		// or maybe I will just print a message "system working" every 10 seconds...
		uint8_t command = USART_ReceiveData(&USART2_Handle);

		if (command == 'F'){
			TIM_SetCompare1(TIM2, 2000);
			software_delay(2000000);
			TIM_SetCompare1(TIM2, 0);

			char done_msg[] = "Feed Complete.\r\n";
			USART_SendData(&USART2_Handle, (uint8_t*)done_msg, strlen(done_msg));

		}
		else if (command == 'H') { // H for "Hello" or "Handshake"{
			char ready_msg[] = "System Ready!\r\n";
			USART_SendData(&USART2_Handle, (uint8_t*)ready_msg, strlen(ready_msg));
		}
		else {
			TIM_SetCompare1(TIM2, 0);
		}
	}
}
